// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Account Type Enum for Transfer System
enum AccountType {
  BASIC // Legacy - to be deprecated
  TRADING
  TRIPARTY
  SMART_CONTRACT
  EOA
}

// Portfolio Fee Structure Enums (based on Python StrategyFeeTypes)
enum PortfolioFeeType {
  FIXED // Fixed percentage fee
  GROSS_RETURN // Based on gross return performance
  TOTAL_ALLOCATION // Based on total allocation amount
}

enum PaymentFrequency {
  MONTHLY
  QUARTERLY
  ANNUALLY
}

// HRP Trading Account Type Enum
enum HrpTradingAccountType {
  FUNDING
  OTHER
}

// Fund Model - Core Entities

model Department {
  id                   Int      @id @default(autoincrement())
  name                 String   @unique @db.VarChar(255)
  description          String?
  oneTokenDepartmentId String?  @unique @map("onetoken_department_id") @db.VarChar(255)
  createdAt            DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt            DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  shareClasses ShareClass[]
}

model ShareClass {
  id           Int      @id @default(autoincrement())
  name         String   @unique @db.VarChar(255)
  denomCcy     String?  @db.VarChar(50) // Denomination currency (USD, EUR, BTC, etc.)
  apiKeys      Json?    @map("api_keys")
  departmentId Int?     @map("department_id")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  department Department? @relation(fields: [departmentId], references: [id])
  portfolios Portfolio[]

  // Investments to the share class.
  // To get investors, lookup ShareClassInvestor through ShareClassInvestment.
  investments ShareClassInvestment[]

  // Redemptions from the share class.
  // To get investors, lookup ShareClassInvestor through ShareClassRedemption.
  redemptions ShareClassRedemption[]

  tradingAccounts      TradingAccount[]
  tripartyAccounts     TripartyAccount[]
  smartContractWallets SmartContractWallet[]
  hrpTradingAccounts   HrpTradingAccount[]   @relation("HrpTradingAccounts")
  hrpBasicAccounts     HrpBasicAccount[]     @relation("HrpBasicAccounts")
  efficientFrontiers   EfficientFrontier[]

  // Performance tracking
  grossNavs    ShareClassGrossNav[]
  grossReturns ShareClassGrossReturn[]
  feeLedgers   FeeLedger[]
}

model ShareClassGrossNav {
  id                                BigInt   @id @default(autoincrement())
  snapshotId                        String   @map("snapshot_id") @db.VarChar(255) // Unique identifier for this valuation snapshot
  valuationTime                     DateTime @map("valuation_time") @db.Timestamptz(6)
  grossNav                          Decimal  @map("gross_nav") @db.Decimal(16, 8)
  cumulativeTransfers               Decimal  @map("cumulative_transfers") @db.Decimal(16, 8)
  adjustedGrossPnl                  Decimal  @map("adjusted_gross_pnl") @db.Decimal(16, 8)
  cumulativeInvestmentsNRedemptions Decimal  @map("cumulative_investments_n_redemptions") @db.Decimal(16, 8)
  shareClassId                      Int      @map("shareclass_id")
  createdAt                         DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt                         DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  shareClass        ShareClass         @relation(fields: [shareClassId], references: [id], onDelete: Cascade)
  shareClassNetNavs ShareClassNetNav[] // Multiple net calculations can derive from same gross
  // Note: ShareClassGrossReturn is paired via snapshotId (not direct FK)

  // Constraints to ensure snapshot integrity
  @@unique([shareClassId, snapshotId], name: "unique_shareclass_snapshot_nav")
  @@index([snapshotId], name: "idx_shareclass_snapshot_id_nav")
}

model ShareClassNetNav {
  id                     BigInt   @id @default(autoincrement())
  netNav                 Decimal  @map("net_nav") @db.Decimal(16, 8)
  hrpLoan                Decimal  @map("hrp_loan") @db.Decimal(16, 8)
  mgmtFee                Decimal  @map("mgmt_fee") @db.Decimal(16, 8)
  hwm                    Decimal  @map("hwm") @db.Decimal(16, 8)
  cumulativeIncentiveFee Decimal  @map("cumulative_incentive_fee") @db.Decimal(16, 8)
  financingFee           Decimal  @map("financing_fee") @db.Decimal(16, 8)
  ersFee                 Decimal  @map("ers_fee") @db.Decimal(16, 8)
  custodyFee             Decimal  @map("custody_fee") @db.Decimal(16, 8)
  shareClassGrossNavId   BigInt   @map("shareclass_gross_nav_id")
  createdAt              DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt              DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  shareClassGrossNav ShareClassGrossNav @relation(fields: [shareClassGrossNavId], references: [id], onDelete: Cascade)
}

model ShareClassGrossReturn {
  id            BigInt   @id @default(autoincrement())
  snapshotId    String   @map("snapshot_id") @db.VarChar(255) // Pairs with ShareClassGrossNav via same snapshotId + shareClassId
  valuationTime DateTime @map("valuation_time") @db.Timestamptz(6)
  grossReturn   Decimal  @map("gross_return") @db.Decimal(16, 8)
  shareClassId  Int      @map("shareclass_id")
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt     DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  shareClass ShareClass            @relation(fields: [shareClassId], references: [id], onDelete: Cascade)
  netReturns ShareClassNetReturn[]
  // Note: Paired ShareClassGrossNav found via matching (shareClassId, snapshotId)

  // Constraints to ensure snapshot integrity and pairing
  @@unique([shareClassId, snapshotId], name: "unique_shareclass_snapshot_return")
  @@index([snapshotId], name: "idx_shareclass_snapshot_id_return")
}

model ShareClassNetReturn {
  id                      BigInt   @id @default(autoincrement())
  netReturn               Decimal  @map("net_return") @db.Decimal(16, 8)
  shareClassGrossReturnId BigInt   @map("shareclass_gross_return_id")
  createdAt               DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt               DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  shareClassGrossReturn ShareClassGrossReturn @relation(fields: [shareClassGrossReturnId], references: [id], onDelete: Cascade)
}

// HRP Fee Event Sourcing System
model FeeLedger {
  id                    BigInt   @id @default(autoincrement())
  externalId            String?  @unique @map("external_id") @db.VarChar(255) // HRP fee calculation ID for deduplication
  incurredAt            DateTime @map("incurred_at") @db.Timestamptz(6)
  providerChargeQty     Decimal  @map("provider_charge_qty") @db.Decimal(36, 8) // Amount from HRP
  internalCalculatedQty Decimal  @map("internal_calculated_qty") @db.Decimal(36, 8) // Our calculation
  denomination          String   @db.VarChar(50) // Currency/asset type
  feeType               String   @map("fee_type") @db.VarChar(50) // CIP, ERS, FINANCING
  shareClassId          Int      @map("shareclass_id")
  rawData               Json?    @map("raw_data") // Full HRP response for debugging
  createdAt             DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt             DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  shareClass   ShareClass    @relation(fields: [shareClassId], references: [id], onDelete: Cascade)
  cipFee       CipFee? // ONE-TO-ONE optional relationships
  ersFee       ErsFee?
  financingFee FinancingFee?

  @@index([incurredAt, shareClassId], name: "idx_fee_time_shareclass")
  @@index([externalId], name: "idx_fee_external_id")
  @@index([feeType, shareClassId], name: "idx_fee_type_shareclass")
}

// CIP Fee details (Trading Account specific)
model CipFee {
  id                  BigInt  @id @default(autoincrement())
  feeLedgerId         BigInt  @unique @map("fee_ledger_id")
  hrpTradingAccountId BigInt  @map("hrp_trading_account_id")
  annualizedRate      Decimal @map("annualized_rate") @db.Decimal(36, 4)

  feeLedger         FeeLedger         @relation(fields: [feeLedgerId], references: [id], onDelete: Cascade)
  hrpTradingAccount HrpTradingAccount @relation("HrpTradingAccountCipFees", fields: [hrpTradingAccountId], references: [id])
}

// ERS Fee details (HRP Basic Account level)
model ErsFee {
  id                BigInt  @id @default(autoincrement())
  feeLedgerId       BigInt  @unique @map("fee_ledger_id")
  hrpBasicAccountId BigInt  @map("hrp_basic_account_id")
  annualizedRate    Decimal @map("annualized_rate") @db.Decimal(36, 4)

  feeLedger       FeeLedger       @relation(fields: [feeLedgerId], references: [id], onDelete: Cascade)
  hrpBasicAccount HrpBasicAccount @relation("HrpBasicAccountErsFees", fields: [hrpBasicAccountId], references: [id])
}

// Financing Fee details (Borrowing costs)
model FinancingFee {
  id                BigInt  @id @default(autoincrement())
  feeLedgerId       BigInt  @unique @map("fee_ledger_id")
  hrpBasicAccountId BigInt  @map("hrp_basic_account_id")
  annualizedRate    Decimal @map("annualized_rate") @db.Decimal(36, 4)
  totalBorrowed     Decimal @map("total_borrowed") @db.Decimal(36, 8)
  assetBorrowed     String  @map("asset_borrowed") @db.VarChar(50)

  feeLedger       FeeLedger       @relation(fields: [feeLedgerId], references: [id], onDelete: Cascade)
  hrpBasicAccount HrpBasicAccount @relation("HrpBasicAccountFinancingFees", fields: [hrpBasicAccountId], references: [id])
}

model ShareClassInvestor {
  id        BigInt   @id @default(autoincrement())
  name      String   @db.VarChar(255)
  email     String   @unique @db.VarChar(254)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  investments ShareClassInvestment[]
  redemptions ShareClassRedemption[]
}

model ShareClassInvestment {
  id           BigInt   @id @default(autoincrement())
  quantity     Decimal  @db.Decimal(20, 2)
  denomCcy     String   @db.VarChar(50) // Denomination currency (USD, EUR, BTC, etc.). This should be identical to the share class denomCcy.
  investorId   BigInt   @map("investor_id")
  shareClassId Int      @map("shareclass_id")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // TODO: we need to add status to track the investment status.

  investor   ShareClassInvestor @relation(fields: [investorId], references: [id], onDelete: Cascade)
  shareClass ShareClass         @relation(fields: [shareClassId], references: [id], onDelete: Cascade)
}

model ShareClassRedemption {
  id           BigInt   @id @default(autoincrement())
  quantity     Decimal  @db.Decimal(20, 2)
  denomCcy     String   @db.VarChar(50) // Denomination currency (USD, EUR, BTC, etc.). This should be identical to the share class denomCcy.
  payoutCcy    String   @db.VarChar(50) // Payout currency (USD, EUR, BTC, etc.). If investor invested in $ and redeemed in £, this should be £.
  investorId   BigInt   @map("investor_id")
  shareClassId Int      @map("shareclass_id")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // TODO: we need to add status to track the redemption status.
  // We may need to add a field to record the payout amount and ccy.

  investor   ShareClassInvestor @relation(fields: [investorId], references: [id], onDelete: Cascade)
  shareClass ShareClass         @relation(fields: [shareClassId], references: [id], onDelete: Cascade)
}

model Portfolio {
  id                 Int       @id @default(autoincrement())
  name               String?   @db.VarChar(255)
  dataSource         String?   @map("data_source") @db.VarChar(255) // e.g. "1token"
  externalId         String?   @map("external_id") @db.VarChar(255) // e.g. "fund/h47z03"
  paymentFrequency   String?   @map("payment_frequency") @db.VarChar(255)
  managementFee      Decimal?  @map("management_fee") @db.Decimal(8, 4)
  incentiveFee       Decimal?  @map("incentive_fee") @db.Decimal(8, 4)
  managerId          BigInt?   @map("manager_id")
  shareClassId       Int?      @map("shareclass_id")
  allocationQuantity Decimal   @map("allocation_quantity") @db.Decimal(16, 4)
  status             String?   @db.VarChar(50)
  inceptionTime      DateTime? @map("inception_time") @db.Timestamptz(6)
  settlementTime     DateTime? @map("settlement_time") @db.Timestamptz(6)
  metadata           Json?
  createdAt          DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt          DateTime  @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  manager                  PortfolioManager?         @relation(fields: [managerId], references: [id])
  shareClass               ShareClass?               @relation(fields: [shareClassId], references: [id])
  // longExposureHistory       LongExposureHistory[]
  // shortExposureHistory      ShortExposureHistory[]
  // grossExposureHistory      GrossExposureHistory[]
  // netExposureHistory        NetExposureHistory[]
  // volatilityHistory         VolatilityHistory[]
  feeStructures            PortfolioFeeStructure[] // Dynamic time-based fee configurations
  valuations               PortfolioValuation[]
  portfolioCalculations    PortfolioCalculation[]  // Add portfolio calculations
  tradingAccounts          TradingAccount[]
  accountPortfolioMappings AccountPortfolioMapping[]
  tradingSmartContracts    TradingSmartContract[]
  hrpTradingAccounts       HrpTradingAccount[]       @relation("PortfolioHrpTradingAccounts")

  // Position relationships
  posSpots             PosSpot[]
  posCalls             PosCall[]
  posPuts              PosPut[]
  posPerps             PosPerp[]
  loans                Loan[]
  aerodromeLpPositions AerodromeLpPosition[]
}

// Portfolio Performance Tracking - Unified Model
model PortfolioValuation {
  id            BigInt   @id @default(autoincrement())
  snapshotId    String   @map("snapshot_id") @db.VarChar(255) // Unique identifier for this valuation snapshot
  valuationFrom DateTime @map("valuation_from") @db.Timestamptz(6)
  valuationTo   DateTime @map("valuation_to") @db.Timestamptz(6)

  cumulativeTransfers Decimal? @map("cumulative_transfers") @db.Decimal(16, 8)
  adjustedGrossPnl    Decimal? @map("adjusted_gross_pnl") @db.Decimal(16, 8)

  // NAV fields (previously from PortfolioGrossNav and PortfolioNetNav)
  netAssets   Decimal? @map("net_assets") @db.Decimal(25, 15)
  netNav      Decimal? @map("net_nav") @db.Decimal(16, 8)
  // Return fields (previously from PortfolioGrossReturn and PortfolioNetReturn)
  grossReturn Decimal? @map("gross_return") @db.Decimal(16, 8)
  netReturn   Decimal? @map("net_return") @db.Decimal(16, 8)

  // === HIGH WATER MARK (HWM) FIELDS ===
  // Based on Py-PMS fund_model_netnav table structure
  adjustedNetPnl Decimal? @map("adjusted_net_pnl") @db.Decimal(16, 8) // Net PnL after fees (basis for HWM calculation)
  hwm            Decimal? @default(0) @map("hwm") @db.Decimal(18, 6) // Portfolio-level HWM (matches Py-PMS precision)
  aboveHwmNav    Decimal? @map("above_hwm_nav") @db.Decimal(16, 8) // Performance above HWM (used for incentive fee calculation)

  // === FEE TRACKING FIELDS ===
  // Management Fee Collection (addresses critical gap identified in fee analysis)
  incrementalManagementFee Decimal? @default(0) @map("incremental_management_fee") @db.Decimal(16, 8) // Daily management fee earned
  cumulativeManagementFee  Decimal? @default(0) @map("cumulative_management_fee") @db.Decimal(16, 8) // Total management fee accumulated
  ytdManagementFee         Decimal? @default(0) @map("ytd_management_fee") @db.Decimal(16, 8) // Year-to-date management fee

  // Incentive Fee Collection (matching Py-PMS structure)
  incrementalIncentiveFee Decimal? @default(0) @map("incremental_incentive_fee") @db.Decimal(16, 8) // Daily incentive fee earned
  cumulativeIncentiveFee  Decimal? @default(0) @map("cumulative_incentive_fee") @db.Decimal(16, 8) // Total incentive fee accumulated  
  ytdIncentiveFee         Decimal? @default(0) @map("ytd_incentive_fee") @db.Decimal(16, 8) // Year-to-date incentive fee
  incentiveFeeRate        Decimal? @map("incentive_fee_rate") @db.Decimal(5, 4) // Applied incentive fee rate for this period

  // === HWM BUSINESS LOGIC TRACKING ===
  isPayoutScheduleEnd Boolean? @default(false) @map("is_payout_schedule_end") // Whether this valuation is at payout schedule end
  hwmResetReason      String?  @map("hwm_reset_reason") @db.VarChar(50) // Reason for HWM reset: "PAYOUT_SCHEDULE", "NEGATIVE_PERFORMANCE", null

  // Additional metadata for 1Token integration
  dataSource   String? @map("data_source") @db.VarChar(50) // e.g., "1token", "manual"
  // externalSnapshotId      String?  @map("external_snapshot_id") @db.VarChar(255) // External system's snapshot ID
  metadata     Json? // Store raw API response or additional data
  valuationCcy String? @map("valuation_ccy") @db.VarChar(50) // Currency code (btc, usd, eth, etc.)

  portfolioId Int      @map("portfolio_id")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  portfolio Portfolio @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
  portfolioCalculations PortfolioCalculation[] // Add reverse relation

  // Constraints to ensure snapshot integrity
  @@unique([portfolioId, snapshotId], name: "unique_portfolio_valuation_snapshot")
  @@index([snapshotId], name: "idx_portfolio_valuation_snapshot")
  @@index([valuationFrom], name: "idx_portfolio_valuation_from")
  @@index([valuationTo], name: "idx_portfolio_valuation_to")
  @@index([valuationFrom, valuationTo], name: "idx_portfolio_valuation_period")
  @@index([dataSource], name: "idx_portfolio_valuation_data_source")
  // === HWM-SPECIFIC INDEXES ===
  @@index([portfolioId, valuationFrom], name: "idx_portfolio_hwm_lookup") // For HWM calculations by date
  @@index([portfolioId, valuationFrom, hwm], name: "idx_portfolio_hwm_tracking") // For HWM progression tracking
  @@index([portfolioId, isPayoutScheduleEnd], name: "idx_portfolio_payout_periods") // For payout schedule queries
}

// Portfolio Calculation Model - Tracks net inflow and PnL calculations with cumulative support
model PortfolioCalculation {
  id              BigInt   @id @default(autoincrement())
  
  // Link to PortfolioValuation period
  valuationFrom   DateTime @map("valuation_from") @db.Timestamptz(6)
  valuationTo     DateTime @map("valuation_to") @db.Timestamptz(6)
  
  // Net Assets (from PortfolioValuation)
  netAssets       Decimal  @map("net_assets") @db.Decimal(25, 15)
  
  // CUMULATIVE CALCULATION FIELDS
  cumulativeNetInflow    Decimal  @map("cumulative_net_inflow") @db.Decimal(25, 15)    // Total net inflow up to valuationTo
  incrementalNetInflow   Decimal  @map("incremental_net_inflow") @db.Decimal(25, 15)   // Net inflow for this period only
  
  // PnL Calculations
  pnl             Decimal  @map("period_pnl") @db.Decimal(25, 15)      // netAssets - cumulativeNetInflow
  netPnl          Decimal  @map("net_pnl") @db.Decimal(25, 15)         // pnl - fees (gross PnL minus fees)
  
  // CHAIN LINKAGE - Single linked list: prev <- this -> next
  // previousCalculationId is null for HEAD (first calculation)
  // nextCalculation is null for TAIL (last calculation) 
  previousCalculationId  BigInt?  @unique @map("previous_calculation_id") // Link to previous calculation in chain (null for head)
  previousCalculation    PortfolioCalculation? @relation("CalculationChain", fields: [previousCalculationId], references: [id])
  nextCalculation        PortfolioCalculation? @relation("CalculationChain")  // null for tail
  
  // VALIDATION FIELDS
  calculationHash String?  @map("calculation_hash") @db.VarChar(64)    // Hash of inputs for consistency check
  isVerified      Boolean  @default(false) @map("is_verified")         // Whether calculation has been validated
  
  // Metadata
  calculationMethod String? @map("calculation_method") @db.VarChar(50) // e.g., "TIME_WEIGHTED", "MONEY_WEIGHTED"
  denomCcy          String? @map("currency") @db.VarChar(10)           // Currency denomination
  metadata          Json?                                              // Additional calculation details
  
  // Relationships
  portfolioId      Int      @map("portfolio_id")
  portfolio        Portfolio @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
  
  // Link to PortfolioValuation - REQUIRED 1:1 mapping
  valuationId      BigInt   @map("valuation_id")                       // Required - no nullable
  valuation        PortfolioValuation @relation(fields: [valuationId], references: [id], onDelete: Cascade)
  
  // Timestamps
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)
  
  // Constraints and Indexes
  @@unique([valuationId], name: "unique_valuation_calculation")        // Enforce 1:1 mapping
  @@unique([portfolioId, valuationFrom, valuationTo], name: "unique_portfolio_calculation_period")
  @@unique([portfolioId, previousCalculationId], name: "unique_portfolio_chain_link") // Ensure proper chain within portfolio
  
  // Chain traversal indexes
  @@index([portfolioId, valuationTo], name: "idx_portfolio_calc_chain") // For finding previous calculation
  @@index([previousCalculationId], name: "idx_calc_chain_link")         // For chain traversal
  
  // Existing indexes
  @@index([portfolioId, valuationFrom], name: "idx_portfolio_calc_lookup")
  @@index([valuationId], name: "idx_portfolio_calc_valuation")
  @@index([valuationFrom, valuationTo], name: "idx_portfolio_calc_period")
  
  // Gap detection indexes
  @@index([portfolioId, valuationFrom, valuationTo], name: "idx_portfolio_calc_gap_detection")
}

// TODO: We may need another model to track all the fees we deduct from the strategy.

model PortfolioManager {
  id         BigInt   @id @default(autoincrement())
  name       String   @db.VarChar(255)
  production Boolean  @default(false)
  notes      Json?
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  portfolios Portfolio[]
}

model Counterparty {
  id               Int      @id @default(autoincrement())
  name             String   @unique @db.VarChar(255)
  description      String?
  type             String?  @db.VarChar(50)
  alternativeNames Json?    @map("alternative_names")
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  tradingAccountsAsVenue      TradingAccount[]      @relation("VenueCounterparty")
  tripartyAccountsAsVenue     TripartyAccount[]     @relation("VenueCounterparty")
  tripartyAccountsAsSecond    TripartyAccount[]     @relation("SecondOwnerCounterparty")
  eoaWalletsAsVenue           EOAWallet[]           @relation("VenueCounterparty")
  smartContractWalletsAsVenue SmartContractWallet[] @relation("VenueCounterparty")
  hrpTradingAccountsAsVenue   HrpTradingAccount[]   @relation("HrpTradingVenue")
  callOptions                 PosCall[]
  putOptions                  PosPut[]
  loans                       Loan[]
  perpetualFutures            PosPerp[]
  futureQuotes                FutureQuotes[]
  percentageFees              PercentageFee[]
}

// Position models now directly link to Portfolio instead of using ProductMaster

// ShareClass Performance Tracking
// TODO: COMMENTED OUT FOR REFACTORING INTO 4 MODELS
// model ShareClassPnl {
//   id                                    BigInt   @id @default(autoincrement())
//   valuationTime                         DateTime @map("valuation_time") @db.Timestamptz(6)
//   grossNav                             Decimal  @map("gross_nav") @db.Decimal(16, 8)
//   cumulativeTransfers                  Decimal  @map("cumulative_transfers") @db.Decimal(16, 8)
//   adjustedGrossPnl                     Decimal  @map("adjusted_gross_pnl") @db.Decimal(16, 8)
//   cumulativeInvestmentsNRedemptions    Decimal  @map("cumulative_investments_n_redemptions") @db.Decimal(16, 8)
//   hrpLoan                              Decimal  @map("hrp_loan") @db.Decimal(16, 8)
//   mgmtFee                              Decimal  @map("mgmt_fee") @db.Decimal(16, 8)
//   hwm                                  Decimal  @map("hwm") @db.Decimal(16, 8)
//   cumulativeIncentiveFee               Decimal  @map("cumulative_incentive_fee") @db.Decimal(16, 8)
//   financingFee                         Decimal  @map("financing_fee") @db.Decimal(16, 8)
//   ersFee                               Decimal  @map("ers_fee") @db.Decimal(16, 8)
//   custodyFee                           Decimal  @map("custody_fee") @db.Decimal(16, 8)
//   netNav                               Decimal  @map("net_nav") @db.Decimal(16, 8)
//   netReturns                           Decimal  @map("net_returns") @db.Decimal(16, 8)
//   shareClassId                         Int      @map("shareclass_id")
//   createdAt                            DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
//   updatedAt                            DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)
//
//   // Relationships
//   shareClass ShareClass @relation(fields: [shareClassId], references: [id], onDelete: Cascade)
//
// }

// ShareClass Performance Tracking (NEW STRUCTURE)

// Exposure Tracking (Time Series) - COMMENTED OUT FOR NOW
// model LongExposureHistory {
//   id              BigInt   @id @default(autoincrement())
//   longMarketValue Decimal  @map("long_market_value") @db.Decimal(12, 8)
//   strategyId      Int      @map("strategy_id")
//   filledAt        DateTime @map("filled_at") @db.Timestamptz(6)
//   createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
//   updatedAt       DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)
//
//   // Relationships
//   strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)
//
// }

// model ShortExposureHistory {
//   id               BigInt   @id @default(autoincrement())
//   shortMarketValue Decimal  @map("short_market_value") @db.Decimal(12, 8)
//   strategyId       Int      @map("strategy_id")
//   filledAt         DateTime @map("filled_at") @db.Timestamptz(6)
//   createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
//   updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)
//
//   // Relationships
//   strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)
//
// }

// model GrossExposureHistory {
//   id               BigInt   @id @default(autoincrement())
//   grossMarketValue Decimal  @map("gross_market_value") @db.Decimal(12, 8)
//   strategyId       Int      @map("strategy_id")
//   filledAt         DateTime @map("filled_at") @db.Timestamptz(6)
//   createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
//   updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)
//
//   // Relationships
//   strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)
//
// }

// model NetExposureHistory {
//   id             BigInt   @id @default(autoincrement())
//   netMarketValue Decimal  @map("net_market_value") @db.Decimal(12, 8)
//   strategyId     Int      @map("strategy_id")
//   filledAt       DateTime @map("filled_at") @db.Timestamptz(6)
//   createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
//   updatedAt      DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)
//
//   // Relationships
//   strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)
//
// }

// model VolatilityHistory {
//   id                   BigInt   @id @default(autoincrement())
//   annualizedVolatility Decimal  @map("annualized_volatility") @db.Decimal(8, 4)
//   lookbackDays         Int      @map("lookback_days")
//   strategyId           Int      @map("strategy_id")
//   createdAt            DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
//   updatedAt            DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)
//
//   // Relationships
//   strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)
//
// }

// Placeholder models for complex relationships - will be expanded later

model TradingAccount {
  id              BigInt    @id @default(autoincrement())
  name            String?   @db.VarChar(255) // Account unified name (e.g., "1token/tradeacc/bitmexprop/vsgm1h")
  alias           String?   @db.VarChar(255) // 1Token account alias (e.g., "AC_TG_07_BTC")
  status          String?   @db.VarChar(50) // 1Token account status (e.g., "api-paused", "active")
  type            String?   @db.VarChar(50) // 1Token account type (e.g., "prop", "derivative", "spot")
  remark          String? // Additional remarks or notes from 1Token
  isSubAccount    Boolean   @default(false) @map("is_sub_account") // Whether this is a sub-account
  accountUid      String?   @map("account_uid") @db.VarChar(255) // 1Token account UID
  masterAccountId BigInt?   @map("master_account_id") // Foreign key to master TradingAccount if this is a sub-account
  balanceUsd      String?   @map("balance_usd") @db.VarChar(50) // USD balance from 1Token (stored as string)
  // oneTokenCreateTime  BigInt?                  @map("onetoken_create_time") // 1Token account creation timestamp (nanoseconds)
  // pausedTime          BigInt?                  @map("paused_time") // 1Token account pause timestamp (nanoseconds)
  infoUpdateTime  DateTime? @map("info_update_time") @db.Timestamptz(6) // Last info update timestamp from 1Token
  portfolioId     Int?      @map("portfolio_id") // Which portfolio has trading access to this account
  venueId         Int?      @map("venue_id") // Trading venue/exchange where account is held
  shareClassId    Int?      @map("share_class_id") // Direct relationship to ShareClass for fee processing
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  portfolio                Portfolio?                @relation(fields: [portfolioId], references: [id])
  shareClass               ShareClass?               @relation(fields: [shareClassId], references: [id])
  venue                    Counterparty?             @relation("VenueCounterparty", fields: [venueId], references: [id])
  masterAccount            TradingAccount?           @relation("MasterSubAccount", fields: [masterAccountId], references: [id])
  subAccounts              TradingAccount[]          @relation("MasterSubAccount")
  accountPortfolioMappings AccountPortfolioMapping[]
}

model TripartyAccount {
  id                 BigInt   @id @default(autoincrement())
  accountIdentifiers Json?    @map("account_identifiers")
  name               String?  @db.VarChar(255)
  denomination       String?  @db.VarChar(50)
  ownerId            Int?     @map("owner_id")
  secondOwnerId      Int?     @map("second_owner_id")
  venueId            Int?     @map("venue_id")
  createdAt          DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt          DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  owner       ShareClass?   @relation(fields: [ownerId], references: [id])
  secondOwner Counterparty? @relation("SecondOwnerCounterparty", fields: [secondOwnerId], references: [id])
  venue       Counterparty? @relation("VenueCounterparty", fields: [venueId], references: [id])
}

// HRP-specific trading account model (separate from 1Token TradingAccount)
model HrpTradingAccount {
  id           BigInt                 @id @default(autoincrement())
  name         String                 @unique @db.VarChar(255) // HRP account name (e.g., "hrp12345")
  type         HrpTradingAccountType  @default(OTHER) // Account type: FUNDING or OTHER
  venueId      Int                    @map("venue_id") // Exchange/venue where account is held
  shareClassId Int                    @map("share_class_id") // Associated share class
  portfolioId  Int?                   @map("portfolio_id") // Associated portfolio (optional)
  createdAt    DateTime               @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime               @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  venue      Counterparty @relation("HrpTradingVenue", fields: [venueId], references: [id])
  shareClass ShareClass   @relation("HrpTradingAccounts", fields: [shareClassId], references: [id])
  portfolio  Portfolio?   @relation("PortfolioHrpTradingAccounts", fields: [portfolioId], references: [id])
  cipFees    CipFee[]     @relation("HrpTradingAccountCipFees")

  // Indexes for performance
  @@index([shareClassId], name: "idx_hrp_trading_share_class")
  @@index([venueId], name: "idx_hrp_trading_venue")
  @@index([portfolioId], name: "idx_hrp_trading_portfolio")
}

// HRP-specific basic account model (replacing BasicAccount for HRP)
model HrpBasicAccount {
  id           BigInt   @id @default(autoincrement())
  name         String   @unique @db.VarChar(255) // HRP basic account name
  denomination String?  @db.VarChar(50) // Account denomination currency
  shareClassId Int      @map("share_class_id") // Owner share class
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  shareClass ShareClass @relation("HrpBasicAccounts", fields: [shareClassId], references: [id])

  // Fee relationships (migrated from BasicAccount)
  hrpErsFees       ErsFee[]       @relation("HrpBasicAccountErsFees")
  hrpFinancingFees FinancingFee[] @relation("HrpBasicAccountFinancingFees")

  // Index for performance
  @@index([shareClassId], name: "idx_hrp_basic_share_class")
}

model SmartContractWallet {
  id                 BigInt   @id @default(autoincrement())
  accountIdentifiers Json?    @map("account_identifiers")
  name               String?  @db.VarChar(255)
  denomination       String?  @db.VarChar(50)
  address            String?  @db.VarChar(255) // Blockchain wallet address
  venueId            Int?     @map("venue_id")
  ownerId            Int?     @map("owner_id")
  createdAt          DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt          DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  owner                 ShareClass?            @relation(fields: [ownerId], references: [id])
  venue                 Counterparty?          @relation("VenueCounterparty", fields: [venueId], references: [id])
  tradingSmartContracts TradingSmartContract[]
}

model EOAWallet {
  id                 BigInt   @id @default(autoincrement())
  accountIdentifiers Json?    @map("account_identifiers")
  name               String?  @db.VarChar(255)
  denomination       String?  @db.VarChar(50)
  venueId            Int?     @map("venue_id")
  createdAt          DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt          DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  venue Counterparty? @relation("VenueCounterparty", fields: [venueId], references: [id])
}

// Placeholder models for remaining entities
model AuditLog {
  id        BigInt   @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
}

model EfficientFrontier {
  id           BigInt   @id @default(autoincrement())
  shareClassId Int      @map("shareclass_id")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  shareClass ShareClass @relation(fields: [shareClassId], references: [id], onDelete: Cascade)
}

// Portfolio Fee Structure System - Supports dynamic timeframe-based fees
// Based on Python StrategyFeeType model from annamite-india-pms
//
// USAGE EXAMPLE: Dynamic Fee Changes Over Time
// =============================================
// Portfolio starts 2025-01-01 with 20% incentive fee for first 2 months, then 25%:
//
// Record 1 (First Period):
//   portfolioId: 123
//   feeType: FIXED  
//   incentiveFees: [0.20]
//   fromDate: "2025-01-01T00:00:00Z"
//   toDate: "2025-02-28T23:59:59Z"
//   paymentFrequency: MONTHLY
//
// Record 2 (Second Period):
//   portfolioId: 123
//   feeType: FIXED
//   incentiveFees: [0.25]  
//   fromDate: "2025-03-01T00:00:00Z"
//   toDate: null (ongoing)
//   paymentFrequency: MONTHLY
//
// QUERY LOGIC: When calculating fees for any date, filter by:
//   WHERE portfolioId = ? AND fromDate <= ? AND (toDate >= ? OR toDate IS NULL)
//   ORDER BY createdAt DESC LIMIT 1
//
// BUSINESS RULES:
// - No overlapping time periods for same portfolio (enforce at application level)
// - Gaps between periods are allowed (falls back to Portfolio.managementFee/incentiveFee)  
// - Arrays thresholds[] and incentiveFees[] must have same length for tiered structures
//
model PortfolioFeeStructure {
  id          BigInt @id @default(autoincrement())
  portfolioId Int    @map("portfolio_id")

  // Fee structure configuration
  feeType       PortfolioFeeType @map("fee_type") // FIXED, GROSS_RETURN, TOTAL_ALLOCATION
  thresholds    Decimal[]        @map("thresholds") @db.Decimal(16, 8) // Performance thresholds for tiered fees
  incentiveFees Decimal[]        @map("incentive_fees") @db.Decimal(5, 4) // Fee rates corresponding to thresholds

  // Time-based fee periods (enables dynamic fee changes)
  fromDate DateTime  @map("from_date") @db.Timestamptz(6) // When this fee structure starts
  toDate   DateTime? @map("to_date") @db.Timestamptz(6) // When this fee structure ends (null = ongoing)

  // Payment configuration
  paymentFrequency PaymentFrequency @map("payment_frequency") // MONTHLY, QUARTERLY, ANNUALLY

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relationships
  portfolio Portfolio @relation(fields: [portfolioId], references: [id], onDelete: Cascade)

  // Ensure no overlapping date ranges for same portfolio (business rule)
  // Note: This should be enforced at application level as well

  // Indexes for efficient fee structure lookups by date range
  @@index([portfolioId, fromDate, toDate], name: "idx_portfolio_fee_timeframe")
  @@index([portfolioId, fromDate], name: "idx_portfolio_fee_start")
}

model AccountPortfolioMapping {
  id               BigInt   @id @default(autoincrement())
  portfolioId      Int      @map("portfolio_id")
  tradingAccountId BigInt   @map("trading_account_id")
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  portfolio      Portfolio      @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
  tradingAccount TradingAccount @relation(fields: [tradingAccountId], references: [id], onDelete: Cascade)
}

model TradingSmartContract {
  id                    BigInt   @id @default(autoincrement())
  smartContractWalletId BigInt   @map("smartcontractwallet_ptr_id")
  portfolioId           Int      @map("portfolio_id")
  createdAt             DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt             DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  smartContractWallet SmartContractWallet @relation(fields: [smartContractWalletId], references: [id], onDelete: Cascade)
  portfolio           Portfolio           @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
}

model Transfer {
  id            BigInt    @id @default(autoincrement())
  amount        Decimal   @db.Decimal(20, 2)
  denomination  String    @db.VarChar(10)
  valuationTime DateTime? @map("valuation_time") @db.Timestamptz(6)
  transferTime  DateTime? @map("transfer_time") @db.Timestamptz(6)

  // From account with type indicator
  fromAccountType AccountType @map("from_account_type")
  fromAccountId   BigInt      @map("from_account_id")

  // To account with type indicator  
  toAccountType AccountType @map("to_account_type")
  toAccountId   BigInt      @map("to_account_id")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@index([fromAccountType, fromAccountId], name: "idx_transfer_from_account")
  @@index([toAccountType, toAccountId], name: "idx_transfer_to_account")
  @@index([valuationTime], name: "idx_transfer_valuation_time")
  @@index([amount, denomination, valuationTime], name: "idx_transfer_duplicate_detection")
}

// Position Models (grouped together)
model PosSpot {
  id               BigInt   @id @default(autoincrement())
  description      String?
  asset            String   @db.VarChar(50)
  denominatedIn    String   @map("denominated_in") @db.VarChar(50)
  acquisitionPrice Decimal  @map("acquisition_price") @db.Decimal(20, 8)
  quantity         Decimal  @db.Decimal(36, 8) // Amount of the asset
  recordedAt       DateTime @map("recorded_at") @db.Timestamptz(6) // When this position was recorded
  portfolioId      Int?     @map("portfolio_id")
  accountName      String?  @map("account_name") @db.VarChar(255) // Track which account holds this
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  portfolio Portfolio? @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
}

model PosCall {
  id              BigInt   @id @default(autoincrement())
  description     String?
  quoteAsset      String   @map("quote_asset") @db.VarChar(50)
  collateralAsset String   @map("collateral_asset") @db.VarChar(50)
  strikePrice     Decimal  @map("strike_price") @db.Decimal(20, 8)
  quantity        Decimal  @db.Decimal(36, 8) // Number of contracts
  recordedAt      DateTime @map("recorded_at") @db.Timestamptz(6)
  counterpartyId  Int      @map("counterparty_id")
  portfolioId     Int?     @map("portfolio_id")
  accountName     String?  @map("account_name") @db.VarChar(255)
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt       DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  counterparty Counterparty @relation(fields: [counterpartyId], references: [id])
  portfolio    Portfolio?   @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
}

model PosPut {
  id              BigInt   @id @default(autoincrement())
  description     String?
  borrowAsset     String   @map("borrow_asset") @db.VarChar(50)
  collateralAsset String   @map("collateral_asset") @db.VarChar(50)
  strikePrice     Decimal  @map("strike_price") @db.Decimal(20, 8)
  quantity        Decimal  @db.Decimal(36, 8) // Number of contracts
  recordedAt      DateTime @map("recorded_at") @db.Timestamptz(6)
  counterpartyId  Int      @map("counterparty_id")
  portfolioId     Int?     @map("portfolio_id")
  accountName     String?  @map("account_name") @db.VarChar(255)
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt       DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  counterparty Counterparty @relation(fields: [counterpartyId], references: [id])
  portfolio    Portfolio?   @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
}

model PosPerp {
  id                BigInt   @id @default(autoincrement())
  description       String?
  contractStartTime DateTime @map("contract_start_time") @db.Timestamptz(6)
  underlyingAsset   String   @map("underlying_asset") @db.VarChar(50)
  denominatedIn     String   @map("denominated_in") @db.VarChar(50)
  initialPrice      Decimal  @map("initial_price") @db.Decimal(20, 8)
  quantity          Decimal  @db.Decimal(36, 8) // Number of contracts
  recordedAt        DateTime @map("recorded_at") @db.Timestamptz(6)
  counterpartyId    Int      @map("counterparty_id")
  portfolioId       Int?     @map("portfolio_id")
  accountName       String?  @map("account_name") @db.VarChar(255)
  createdAt         DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt         DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  counterparty Counterparty @relation(fields: [counterpartyId], references: [id])
  portfolio    Portfolio?   @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
}

// TODO: Rename Loan to PosLoan
model Loan {
  id              BigInt   @id @default(autoincrement())
  description     String?
  borrowAsset     String   @map("borrow_asset") @db.VarChar(50)
  collateralAsset String   @map("collateral_asset") @db.VarChar(50)
  quantity        Decimal  @db.Decimal(36, 8) // Amount borrowed
  recordedAt      DateTime @map("recorded_at") @db.Timestamptz(6)
  counterpartyId  Int      @map("counterparty_id")
  portfolioId     Int?     @map("portfolio_id")
  accountName     String?  @map("account_name") @db.VarChar(255)
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt       DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  counterparty Counterparty @relation(fields: [counterpartyId], references: [id])
  portfolio    Portfolio?   @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
}

// TODO: Rename AerodromeLpPosition to PosAerodromeLp
model AerodromeLpPosition {
  id          BigInt   @id @default(autoincrement())
  description String?
  quantity    Decimal  @db.Decimal(36, 8) // LP token amount
  recordedAt  DateTime @map("recorded_at") @db.Timestamptz(6)
  portfolioId Int?     @map("portfolio_id")
  accountName String?  @map("account_name") @db.VarChar(255)
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  portfolio Portfolio? @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
}


model FutureQuotes {
  id         BigInt   @id @default(autoincrement())
  dataSource String   @map("data_source") @db.VarChar(50)
  asset      String   @db.VarChar(50)
  price      Decimal  @db.Decimal(20, 8)
  quantity   Decimal  @db.Decimal(20, 8)
  venueId    Int      @map("venue_id")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  venue Counterparty @relation(fields: [venueId], references: [id])
}

// Fee Management System - Simplified for now
model PercentageFee {
  id                 BigInt   @id @default(autoincrement())
  name               String   @db.VarChar(255)
  description        String?
  annualizedRate     Decimal  @map("annualized_rate") @db.Decimal(36, 4)
  settlementSchedule String   @map("settlement_schedule") @db.VarChar(50)
  paidToId           Int      @map("paid_to_id")
  createdAt          DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt          DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  paidTo Counterparty @relation(fields: [paidToId], references: [id])
}

// Historical Currency Exchange Rates
// This table stores daily currency prices in USD for conversion calculations
// Data is fetched daily at 00:00 AM using 1Token API /quote/last-price-before-timestamp
model SpotQuote {
  id            BigInt   @id @default(autoincrement())

  // Currency identification
  symbol        String   @db.VarChar(20)  // Currency symbol (e.g., "btc", "eth", "usdt")
  baseCurrency  String   @default("usd") @map("base_currency") @db.VarChar(10) // Always "usd" for conversion

  // Price data
  price         Decimal  @db.Decimal(25, 15) // Price of 1 unit of symbol in USD (e.g., 1 BTC = 63482.50 USD)

  // Data source information
  dataSource    String   @map("data_source") @db.VarChar(20) // "1token"
  exchange      String   @db.VarChar(10)  // "index" or "cmc" (from 1Token API)
  contract      String?  @db.VarChar(50)  // Contract name from 1Token (e.g., "index/btc.usd")

  // Temporal data
  priceDate     DateTime @map("price_date") @db.Date // Date for this price (YYYY-MM-DD)
  fetchedAt     DateTime @map("fetched_at") @db.Timestamptz(6) // When this data was fetched
  originalTm    BigInt?  @map("original_tm") // Original timestamp from 1Token API (nanoseconds)

  // Metadata
  metadata      Json?    // Store original 1Token API response for debugging

  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt     DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Ensure one price per symbol per date combination
  @@unique([symbol, baseCurrency, priceDate, exchange], name: "unique_currency_daily_rate")

  // Indexes for efficient querying
  @@index([symbol, priceDate], name: "idx_currency_spot_quote_lookup")            // Primary lookup pattern
  @@index([priceDate], name: "idx_currency_spot_quote_date")                      // Date-based queries
  @@index([symbol, priceDate, exchange], name: "idx_currency_spot_quote_symbol")  // Symbol-specific queries
  @@index([fetchedAt], name: "idx_currency_spot_quote_fetch_time")               // Data freshness monitoring
}
